I"¾<h2 id="why-should-we-version-our-apis">Why should we version our APIâ€™s?</h2>

<p>The first time we publish an API for clients to consume, then the users expect that the APIâ€™s do not change suddenly and break their integrations. But the fact is that new requirements will come to the developers maintaining the API and they have to somehow evolve the APIâ€™s without breaking the client integrations at any cost.</p>

<p>So, the only way around this is to version the APIâ€™s as new changes are rolled out. This gives clients the flexibility to use the previous versions of API and continue their business. They can parallely test the new API version on their sandbox and once tested successfully, roll over to the new API version.</p>

<h2 id="typical-scenarios-where-api-versioning-can-cause-problems">Typical scenarios where API versioning can cause problems</h2>

<ul>
  <li>If the previous version of the API targets a set of assemblies &amp; the newer version of the same API targets a different/upgraded version of the assemblies, then it becomes difficult to deploy both sets of assemblies side by side in the same API codebase.</li>
</ul>

<h2 id="approaches-to-api-versioning">Approaches to API versioning</h2>

<blockquote>
  <p>Note that there is no one right way to achieve this. The approach typically depends on your requirements, the way you anticipate changes to occur in your API and the way your clients find it easy to incorporate API verioning changes. So, donâ€™t complicate API versioning with a single best practice. The fact is that there is no single solution to versioning.</p>
</blockquote>

<h3 id="approach-1--uri-versioning">Approach 1 : URI Versioning</h3>

<p>This approach versions API endpoints based on the URI. For example, <code class="highlighter-rouge">https://abc.org/api/v2/customers</code></p>

<h3 id="approach-2--query-string-versioning">Approach 2 : Query String Versioning</h3>

<p>This approach versions API endpoints based on the query string parameter. For example, <code class="highlighter-rouge">https://abc.org/api/customers?v=2.0</code></p>

<h3 id="approach-3--request-header-versioning">Approach 3 : Request Header Versioning</h3>

<p>This approach versions API endpoints based on the <code class="highlighter-rouge">X-Version</code> header. For example,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /api/customers HTTP/1.1
Host: localhost:4000
Content-Type: application/json
X-Version: 2.0
</code></pre></div></div>

<p>In this approach, the good thing is that the API URI is consistent throughout and looks beautiful. But your clients need to know how to generate requests by setting the <code class="highlighter-rouge">X-Version</code> header value to the version that they want to integrate into.</p>

<h3 id="approach-3--accept-header-versioning">Approach 3 : Accept Header Versioning</h3>

<p>This approach versions API endpoints based on the <code class="highlighter-rouge">Accept</code> header. For example,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /api/customers HTTP/1.1
Host: localhost:4000
Content-Type: application/json
Accept: application/json;version=2.0
</code></pre></div></div>

<p>In this approach, the good thing is that the API URI is consistent throughout and looks beautiful. Another advantage of this approach is that we can set the Accept header value when we are setting the data to be passed into the API endpoint. This is more convenient for developers and consumers as they can specify the version of the content that they expect the API to handle. Remember that the structure of the content that a version accepts may be different from the structure that the later version accepts.</p>
:ET